---
title: "Assessment 2 GY476"
output:
  html_document: 
    toc: true
    toc_float: true
    theme: cosmo
---

# Setup and Data Loading

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.align = 'center', fig.width = 12, fig.height = 8)

# Set working directory
wdir <- "/Users/dylanhillier/Library/CloudStorage/OneDrive-LondonSchoolofEconomics/GY476_Geographic_Information_System/assessment02"

# Load required packages
library(tidyverse)
library(ggplot2)
library(dplyr)
library(sf)
library(tmap)
library(tidycensus)
library(grid)
library(osmdata)
library(ggspatial)
library(spatstat)

# Create data directory
ddir <- file.path(wdir, "data")
if(!dir.exists(ddir)) dir.create(ddir)

# Census API key - load from environment variable for security
# To set up: Add CENSUS_API_KEY=your_key_here to your .Renviron file
# Or use: Sys.setenv(CENSUS_API_KEY = "your_key_here") in your R console
api_key <- Sys.getenv("CENSUS_API_KEY")
if(api_key == "") {
  stop("Census API key not found. Please set CENSUS_API_KEY environment variable.")
}
census_api_key(api_key, install = TRUE, overwrite = TRUE)
```

```{r download-data, include=FALSE}
# Download Airbnb listings
if(!file.exists(file.path(ddir, "listing.csv"))) {
  download.file(
    url = "https://data.insideairbnb.com/united-states/ca/los-angeles/2025-09-01/visualisations/listings.csv",
    destfile = file.path(ddir, "listing.csv")
  )
}

# Download neighbourhood boundaries
if(!file.exists(file.path(ddir, "neighbourhoods.geojson"))) {
  download.file(
    url = "https://data.insideairbnb.com/united-states/ca/los-angeles/2025-09-01/visualisations/neighbourhoods.geojson",
    destfile = file.path(ddir, "neighbourhoods.geojson")
  )
}
```

```{r load-data, include=FALSE}
# Airbnb listings
airbnb_raw <- read.csv(file.path(ddir, "listing.csv"))

# Neighbourhood boundaries
neighbourhoods_sf <- st_read(file.path(ddir, "neighbourhoods.geojson"), quiet = TRUE) %>%
  st_set_crs(4326) %>%
  st_transform(32611)

# LA census tract geometry
census_tracts_sf <- st_read(file.path(ddir, "LA_geometry.gpkg"), quiet = TRUE) %>%
  st_transform(32611) %>%
  st_make_valid()

# Census data
census_data <- read.csv(file.path(ddir, "ACS_2019_2023_LA_vars.csv")) %>%
  mutate(
    GEOID = as.character(GEOID),
    GEOID = paste0("06", str_sub(GEOID, start = 2))
  )

# Define bounding boxes
mainland_bbox <- st_bbox(c(xmin = 320000, ymin = 3710000, 
                           xmax = 445000, ymax = 3860000), 
                         crs = 32611)

catalina_bbox <- st_bbox(c(xmin = 340000, ymin = 3678000, 
                           xmax = 390000, ymax = 3708000), 
                         crs = 32611)

# Join census data
census_joined <- census_tracts_sf %>%
  left_join(census_data, by = "GEOID")
```

```{r prepare-airbnb, include=FALSE}
# Calculate IQR bounds for outlier removal
Q1 <- quantile(airbnb_raw$price, 0.25, na.rm = TRUE)
Q3 <- quantile(airbnb_raw$price, 0.75, na.rm = TRUE)
IQR_val <- Q3 - Q1

# Filter outliers and convert to sf object
airbnb_sf <- airbnb_raw %>%
  filter(
    price >= (Q1 - 1.5 * IQR_val) & 
    price <= (Q3 + 1.5 * IQR_val)
  ) %>%
  st_as_sf(coords = c("longitude", "latitude")) %>%
  st_set_crs(4326) %>%      
  st_transform(32611) %>%
  st_make_valid()
```

# Spatial Distribution of Airbnb Listings

```{r figure-1, fig.cap="**Figure 1:** Spatial distribution of Airbnb listings in Los Angeles County by room type. Left panel shows entire home/apartment listings concentrated in coastal and central areas. Right panel displays hotel rooms, private rooms, and shared rooms with similar geographic patterns but lower densities.", fig.width=14, fig.height=8}

# Split by room type
airbnb_entire <- airbnb_sf %>%
  filter(room_type == "Entire home/apt")

airbnb_other <- airbnb_sf %>%
  filter(room_type %in% c("Hotel room", "Private room", "Shared room"))

tmap_mode("plot")

# Panel 1: Entire Home/Apartment
main_entire <- tm_shape(census_tracts_sf, bbox = mainland_bbox) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_shape(airbnb_entire) +
  tm_dots(fill = "darkblue", size = 0.05, fill_alpha = 0.5) +
  tm_title("Entire Home/Apartment", fontface = "bold", size = 1.2) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_layout(frame = TRUE)

inset_entire <- tm_shape(census_tracts_sf, bbox = catalina_bbox) +
  tm_fill(fill = "grey95") +
  tm_borders(col = "grey70", lwd = 0.5) +
  tm_shape(airbnb_entire) +
  tm_dots(fill = "darkblue", size = 0.2, fill_alpha = 0.7) +
  tm_title("Catalina Island", size = 0.7, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white")

# Panel 2: Hotel/Private/Shared Room
main_other <- tm_shape(census_tracts_sf, bbox = mainland_bbox) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_shape(airbnb_other) +
  tm_dots(fill = "darkred", size = 0.05, fill_alpha = 0.5) +
  tm_title("Hotel / Private / Shared Room", fontface = "bold", size = 1.2) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_layout(frame = TRUE)

inset_other <- tm_shape(census_tracts_sf, bbox = catalina_bbox) +
  tm_fill(fill = "grey95") +
  tm_borders(col = "grey70", lwd = 0.5) +
  tm_shape(airbnb_other) +
  tm_dots(fill = "darkred", size = 0.2, fill_alpha = 0.7) +
  tm_title("Catalina Island", size = 0.7, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white")

# Print combined figure
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col = 1))
print(main_entire, vp = viewport(x = 0.5, y = 0.5, width = 0.95, height = 0.95))
print(inset_entire, vp = viewport(x = 0.78, y = 0.17, width = 0.22, height = 0.28))
popViewport()
pushViewport(viewport(layout.pos.col = 2))
print(main_other, vp = viewport(x = 0.5, y = 0.5, width = 0.95, height = 0.95))
print(inset_other, vp = viewport(x = 0.78, y = 0.17, width = 0.22, height = 0.28))
popViewport()
```

# Mean Airbnb Prices by Census Tract

```{r figure-2, fig.cap="**Figure 2:** Choropleth map showing mean Airbnb prices aggregated by census tract. Golden triangles indicate the three highest-priced tracts (concentrated in coastal areas), while red circles mark the three lowest-priced tracts. Color intensity reflects price gradient from yellow (lower) to red (higher).", fig.width=12, fig.height=10}

# Calculate mean price per census tract
tract_prices <- airbnb_sf %>%
  st_join(census_tracts_sf) %>%
  st_drop_geometry() %>%
  group_by(GEOID) %>%
  summarise(mean_price = mean(price, na.rm = TRUE), .groups = 'drop')

# Join prices back to census tract geometry
tracts_with_prices <- census_tracts_sf %>%
  left_join(tract_prices, by = "GEOID")

# Identify top 3 and bottom 3 tracts by price
all_highlight <- tracts_with_prices %>%
  filter(!is.na(mean_price)) %>%
  mutate(price_rank = rank(-mean_price, ties.method = "first")) %>%
  filter(price_rank <= 3 | price_rank >= (max(price_rank) - 2)) %>%
  mutate(
    type = ifelse(price_rank <= 3, "Highest", "Lowest"),
    label = case_when(
      price_rank == 1 ~ "1st Highest",
      price_rank == 2 ~ "2nd Highest",
      price_rank == 3 ~ "3rd Highest",
      price_rank == max(price_rank) ~ "1st Lowest",
      price_rank == max(price_rank) - 1 ~ "2nd Lowest",
      price_rank == max(price_rank) - 2 ~ "3rd Lowest"
    )
  ) %>%
  st_centroid()

highest_tracts <- all_highlight %>% 
  filter(type == "Highest") %>%
  mutate(label = factor(label, levels = c("1st Highest", "2nd Highest", "3rd Highest")))

lowest_tracts <- all_highlight %>% 
  filter(type == "Lowest") %>%
  mutate(label = factor(label, levels = c("1st Lowest", "2nd Lowest", "3rd Lowest")))

tmap_mode("plot")

# Main Map
main_choropleth <- tm_shape(tracts_with_prices, bbox = mainland_bbox) +
  tm_fill(
    fill = "mean_price",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(title = "Mean Price ($)")
  ) +
  tm_borders(col = "grey70", lwd = 0.2) +
  tm_shape(highest_tracts) +
  tm_symbols(
    shape = "label",
    shape.scale = tm_scale_categorical(values = c(24, 25, 23)),
    shape.legend = tm_legend(title = "Highest Price"),
    fill = "#DAA520", size = 0.8, col = "black", lwd = 1.2
  ) +
  tm_shape(lowest_tracts) +
  tm_symbols(
    shape = "label",
    shape.scale = tm_scale_categorical(values = c(21, 22, 8)),
    shape.legend = tm_legend(title = "Lowest Price"),
    fill = "#ee1616", size = 0.8, col = "black", lwd = 1.2
  ) +
  tm_title("Mean Airbnb Price by Census Tract", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_layout(frame = TRUE, legend.outside = TRUE, legend.outside.position = "right")

# Inset Map
inset_choropleth <- tm_shape(tracts_with_prices, bbox = catalina_bbox) +
  tm_fill(
    fill = "mean_price",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = NULL
  ) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_title("Catalina Island", size = 1.0, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white", legend.show = FALSE)

# Print combined figure
grid.newpage()
print(main_choropleth, vp = viewport(x = 0.5, y = 0.5, width = 1, height = 1))
print(inset_choropleth, vp = viewport(x = 0.87, y = 0.145, width = 0.25, height = 0.25))
```

# Socio-Economic Characteristics

```{r figure-3-data, include=FALSE}
# Get renter data from tidycensus
renter_data <- get_acs(
  state = "CA",
  county = "Los Angeles",
  geography = "tract",
  variables = c(total_units = "B25003_001", renter_occupied = "B25003_003"),
  geometry = FALSE,
  year = 2023,
  output = "wide"
) %>% 
  mutate(pct_renter = (renter_occupiedE / total_unitsE) * 100) %>%
  select(GEOID, pct_renter)

# Join renter data to census tracts
renter_sf <- census_tracts_sf %>%
  left_join(renter_data, by = "GEOID")

# Get median income from provided census data
Median_income_sf <- census_tracts_sf %>%
  left_join(
    census_data %>% select(GEOID, Median_income = B19013_001E),
    by = "GEOID"
  )
```

```{r figure-3, fig.cap="**Figure 3:** Socio-economic characteristics of Los Angeles County census tracts. Panel A (left) shows percentage of renter-occupied housing units, with darker red indicating higher rental rates. Panel B (right) displays median household income, where darker blue represents higher income levels. Both maps reveal distinct spatial patterns of socio-economic stratification.", fig.width=14, fig.height=9}

tmap_mode("plot")

# Panel A: Renters
main_renter <- tm_shape(renter_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = "pct_renter",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(title = "Percentage Renters (%)", orientation = "landscape"), 
    col = "white", lwd = 0.1
  ) +
  tm_title("A: Renter Occupancy", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("right", "bottom"), width = 10) +
  tm_layout(frame = TRUE, 
            legend.outside = TRUE, 
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            inner.margins = c(0.02, 0.02, 0.02, 0.02))

inset_renter <- tm_shape(renter_sf, bbox = catalina_bbox) +
  tm_polygons(
    fill = "pct_renter",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(show = FALSE),
    col = "white", lwd = 0.3
  ) +
  tm_title("Catalina Is.", size = 0.6, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 1, bg.color = "white")

# Panel B: Income
main_income <- tm_shape(Median_income_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = "Median_income",
    fill.scale = tm_scale_continuous(values = "GnBu"),
    fill.legend = tm_legend(title = "Median Income ($)", orientation = "landscape"),
    col = "white", lwd = 0.1
  ) +
  tm_title("B: Median Household Income", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("right", "bottom"), width = 10) +
  tm_layout(frame = TRUE, 
            legend.outside = TRUE, 
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            inner.margins = c(0.02, 0.02, 0.02, 0.02))

inset_income <- tm_shape(Median_income_sf, bbox = catalina_bbox) +
  tm_polygons(
    fill = "Median_income",
    fill.scale = tm_scale_continuous(values = "GnBu"),
    fill.legend = tm_legend(show = FALSE),
    col = "white", lwd = 0.3
  ) +
  tm_title("Catalina Is.", size = 0.6, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 1, bg.color = "white")

# Print combined figure
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col = 1))
print(main_renter, vp = viewport(x = 0.5, y = 0.5, width = 0.98, height = 0.98))
print(inset_renter, vp = viewport(x = 0.78, y = 0.25, width = 0.22, height = 0.28))
popViewport()
pushViewport(viewport(layout.pos.col = 2))
print(main_income, vp = viewport(x = 0.5, y = 0.5, width = 0.98, height = 0.98))
print(inset_income, vp = viewport(x = 0.78, y = 0.25, width = 0.22, height = 0.28))
popViewport()
```

# Bivariate Analysis: Price and Rental Patterns

```{r figure-4, fig.cap="**Figure 4:** Bivariate choropleth map examining the relationship between log-transformed Airbnb prices and percentage of renter-occupied housing. The purple-gold color scheme simultaneously displays both variables, revealing areas where high rental rates coincide with elevated Airbnb prices.", fig.width=10, fig.height=10}

# Join renter and price data
summary_sf <- st_join(renter_sf, airbnb_sf, join = st_intersects)

# Prepare bivariate data
adjusted_summary_sf <- summary_sf %>%
  mutate(
    Price = log(price),
    `% That Rent` = pct_renter
  ) %>%
  select(GEOID, Price, `% That Rent`, geom) %>%
  st_as_sf()

tmap_mode("plot")

figure_4_bivariate <- tm_shape(adjusted_summary_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = tm_vars(c("Price", "% That Rent"), multivariate = TRUE, animate = FALSE),
    fill.scale = tm_scale_bivariate(values = "purplegold"),
    fill.chart = tm_chart_heatmap()
  ) +
  tm_title("Bivariate Map: Ln House Price and Percentage Renters", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_layout(
    frame = TRUE, 
    legend.outside = TRUE, 
    legend.outside.position = "bottom",
    legend.outside.size = 0.2,
    inner.margins = c(0.02, 0.02, 0.02, 0.02)
  )

figure_4_bivariate
```

# Restaurant Density Analysis

```{r figure-5-data, include=FALSE, cache=TRUE}
# Query OpenStreetMap for restaurants
test_bbox <- c(-119.473572, 33.493307, -117.051086, 34.633208)

q <- opq(bbox = test_bbox) %>%
  add_osm_feature(key = "amenity", value = "restaurant") %>%
  osmdata_sf()

restaurants <- q$osm_points %>% 
  select(name, geometry) %>% 
  filter(!is.na(geometry)) %>%
  st_coordinates()
```

```{r figure-5, fig.cap="**Figure 5:** Kernel density estimation of restaurant locations across Los Angeles County. Warmer colors (yellow to white) indicate areas of higher restaurant concentration, highlighting commercial and tourist districts. The visualization uses a two-dimensional density estimation with contour lines to delineate density gradients.", fig.width=10, fig.height=8}

# Convert restaurants dataframe to match coordinate system
restaurants_df <- data.frame(restaurants) %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326) %>%
  st_transform(32611)

restaurants_coords <- st_coordinates(restaurants_df)

p <- ggplot() +
  stat_density_2d_filled(
    data = as.data.frame(restaurants_coords),
    aes(x = X, y = Y),
    contour_var = "density",
    bins = 15,
    alpha = 0.9,
    adjust = 1 
  ) +
  geom_sf(
    data = neighbourhoods_sf,
    fill = NA,
    colour = "white",
    linewidth = 0.2
  ) +
  scale_fill_viridis_d(
    option = "inferno",
    name = "Density",
    guide = guide_legend(reverse = TRUE)
  ) +
  coord_sf() +
  labs(
    title = "Restaurant Density",
    x = NULL,
    y = NULL
  ) +
  theme_void(base_size = 12) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", hjust = 0.5, margin = margin(b = 10), color = "white"),
    plot.background = element_rect(fill = "black", colour = NA),
    legend.text = element_text(colour = "white"),
    legend.title = element_text(colour = "white")
  )

print(p)
```

# Proximity Analysis: Airbnbs Near Restaurants

```{r figure-6, fig.cap="**Figure 6:** Proximity analysis showing Airbnb listings within 200-meter walking distance of restaurants in Hollywood. Dark blue points represent Airbnbs within the buffer zone (red shaded area), while grey points show listings outside this range. Red triangles mark restaurant locations. The analysis demonstrates the spatial relationship between accommodation and dining amenities.", fig.width=10, fig.height=8}

# Define target neighbourhood
chosen_neighbourhood <- "Hollywood"

# Filter to neighbourhood
target_sf <- neighbourhoods_sf %>%
  filter(neighbourhood == chosen_neighbourhood)

# Convert restaurants to sf
restaurants_sf <- q$osm_points %>%
  select(name, geometry) %>%
  filter(!is.na(geometry)) %>%
  st_as_sf() %>%
  st_transform(32611)

# Get restaurants in neighbourhood
target_restaurants <- restaurants_sf %>%
  st_filter(target_sf)

# Create 200m buffers
restaurant_buffers <- st_buffer(target_restaurants, dist = 200)
buffer_union <- st_union(restaurant_buffers)

# Get Airbnbs in neighbourhood
target_airbnbs <- airbnb_sf %>%
  st_filter(target_sf)

# Find Airbnbs within 200m
airbnbs_near <- target_airbnbs %>%
  filter(lengths(st_intersects(., restaurant_buffers)) > 0)

p <- ggplot() +
  geom_sf(data = target_sf, fill = "#f8f9fa", color = "#495057", linewidth = 0.5) +
  geom_sf(data = buffer_union, aes(fill = "Within 200m"), alpha = 0.2, color = NA) +
  geom_sf(data = target_airbnbs, aes(color = "Outside 200m"), shape = 16, size = 1, alpha = 0.4) +
  geom_sf(data = airbnbs_near, aes(color = "Airbnb (within 200m)"), shape = 16, size = 2) +
  geom_sf(data = target_restaurants, aes(color = "Restaurant"), shape = 17, size = 2) +
  annotation_scale(
    location = "br",
    width_hint = 0.15,
    style = "ticks",
    line_width = 0.5,
    height = unit(0.15, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  annotation_north_arrow(
    location = "tr",
    which_north = "true",
    height = unit(1, "cm"),
    width = unit(1, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm"),
    style = north_arrow_fancy_orienteering
  ) +
  scale_fill_manual(
    name = NULL,
    values = c("Within 200m" = "#e63946"),
    guide = guide_legend(order = 1, override.aes = list(alpha = 0.2))
  ) +
  scale_color_manual(
    name = NULL,
    values = c("Outside 200m" = "grey70", 
               "Airbnb (within 200m)" = "#1d3557", 
               "Restaurant" = "#e63946"),
    guide = guide_legend(order = 2, override.aes = list(
      shape = c(16, 16, 17),
      size = c(2, 3, 3),
      alpha = 1
    ))
  ) +
  labs(
    title = paste("Airbnb Listings within 200m of Restaurants in", chosen_neighbourhood),
    subtitle = paste0(nrow(airbnbs_near), " of ", nrow(target_airbnbs), 
                      " listings within walking distance of ", nrow(target_restaurants), " restaurants"),
    caption = "Data: Inside Airbnb & OpenStreetMap | CRS: EPSG 32611"
  ) +
  theme_void(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 13),
    plot.subtitle = element_text(hjust = 0.5, color = "grey40", margin = margin(t = 5, b = 10)),
    plot.caption = element_text(hjust = 0.5, color = "grey50", size = 8),
    plot.margin = margin(15, 15, 15, 15),
    legend.position = "bottom",
    legend.box.margin = margin(t = 10)
  )

print(p)
```

# Point Pattern Analysis

## Kernel Density Estimation

```{r figure-7, fig.cap="**Figure 7:** Kernel density estimation of all Airbnb listings using point pattern analysis. The heatmap reveals clustering patterns with contour lines indicating concentration levels. This analysis employs a Gaussian kernel with 2km bandwidth to smooth the point distribution across the study area.", fig.width=10, fig.height=8}

# Create boundary
BA_boundary <- st_union(neighbourhoods_sf)
BA_owin_m <- as.owin(BA_boundary)

# Prepare point pattern
coords <- st_coordinates(airbnb_sf)

listings_ppp <- ppp(
  x = coords[, 1],
  y = coords[, 2],
  window = BA_owin_m
)

# Rescale to km
listings_ppp <- rescale(listings_ppp, 1000)
BA_owin <- rescale(BA_owin_m, 1000)
marks(listings_ppp) <- NULL

# Calculate density
K1 <- density.ppp(listings_ppp, sigma = 2)

# Plot
plot(K1, main = "Kernel Density of Airbnb Listings in Los Angeles", las = 1)
contour(K1, add = TRUE)
plot(BA_owin, add = TRUE)
```

## Inverse Distance Weighted Interpolation of Prices

```{r figure-8, fig.cap="**Figure 8:** Inverse distance weighted (IDW) interpolation of Airbnb prices across Los Angeles County. The continuous surface estimation uses listing prices as marks, with colors representing interpolated price values. Warmer colors indicate higher predicted prices, revealing spatial price trends and hotspots. The IDW method weights nearby observations more heavily, creating a smooth price surface.", fig.width=10, fig.height=8}

# Prepare listings with price marks
listings_transformed <- airbnb_sf %>%
  filter(!is.na(price), price > 0)

coords_price <- st_coordinates(listings_transformed)

# Create ppp with price marks
listings_ppp_price <- ppp(
  x = coords_price[, 1],
  y = coords_price[, 2],
  marks = listings_transformed$price,
  window = BA_owin_m
)

# Rescale to km
listings_ppp_price <- rescale(listings_ppp_price, 1000)

# IDW interpolation
price_idw <- Smooth.ppp(listings_ppp_price, sigma = 2)

# Plot
plot(price_idw, main = "IDW Interpolation of Airbnb Prices in Los Angeles", las = 1)
contour(price_idw, add = TRUE)
plot(BA_owin, add = TRUE)
```