---
title: "Assessment 2 GY476"
output:
  html_document: 
    toc: true
    toc_float: true
    theme: cosmo
---

# Setup and Data Loading

Setup and Data Loading In this section, I complete the basic setup for the assessment, such as setting my working directory and creating a data directory for organised and structured file management. I also configure the API key through a .Renviron file for secure access to the American community Survey data.

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.align = 'center', fig.width = 12, fig.height = 8)



wdir <- "/Users/dylanhillier/Library/CloudStorage/OneDrive-LondonSchoolofEconomics/GY476_Geographic_Information_System/assessment02"
library(tidyverse)
library(ggplot2)
library(dplyr)
library(sf)
library(tmap)
library(tidycensus)
library(grid)
library(osmdata)
library(ggspatial)
library(spatstat)

ddir <- file.path(wdir, "data")
if(!dir.exists(ddir)) dir.create(ddir)

# To set up: Add CENSUS_API_KEY=your_key_here to your .Renviron file
api_key <- Sys.getenv("CENSUS_API_KEY")
if(api_key == "") {
  stop("Census API key not found. Please set CENSUS_API_KEY environment variable.")
}
census_api_key(api_key, install = TRUE, overwrite = TRUE)
```

Downloading Airbnb listing(listing.csv) and neighbourhood boundaries from Inside Airbnb for September 2025 snapshot, loaded pre-processed ACS 2019-2023 census data and census tract geometries from the provided geopackage. Additionally, we set bbox ranges, which define the area we are going to examine for the mainland and the islands of Catalina.

```{r download-data, include=FALSE}
# Download Airbnb listings
if(!file.exists(file.path(ddir, "listing.csv"))) {
  download.file(
    url = "https://data.insideairbnb.com/united-states/ca/los-angeles/2025-09-01/visualisations/listings.csv",
    destfile = file.path(ddir, "listing.csv")
  )
}

# Download neighbourhood boundaries
if(!file.exists(file.path(ddir, "neighbourhoods.geojson"))) {
  download.file(
    url = "https://data.insideairbnb.com/united-states/ca/los-angeles/2025-09-01/visualisations/neighbourhoods.geojson",
    destfile = file.path(ddir, "neighbourhoods.geojson")
  )
}


# Airbnb listings
airbnb_raw <- read.csv(file.path(ddir, "listing.csv"))

# Neighbourhood boundaries
neighbourhoods_sf <- st_read(file.path(ddir, "neighbourhoods.geojson"), quiet = TRUE) %>%
  st_set_crs(4326) %>%
  st_transform(32611)

# LA census tract geometry
census_tracts_sf <- st_read(file.path(ddir, "LA_geometry.gpkg"), quiet = TRUE) %>%
  st_transform(32611) %>%
  st_make_valid()

# Census data
census_data <- read.csv(file.path(ddir, "ACS_2019_2023_LA_vars.csv")) %>%
  mutate(
    GEOID = as.character(GEOID),
    GEOID = paste0("06", str_sub(GEOID, start = 2))
  )

# Define bounding boxes
mainland_bbox <- st_bbox(c(xmin = 320000, ymin = 3710000, 
                           xmax = 445000, ymax = 3860000), 
                         crs = 32611)

catalina_bbox <- st_bbox(c(xmin = 340000, ymin = 3678000, 
                           xmax = 390000, ymax = 3708000), 
                         crs = 32611)

# Join census data
census_joined <- census_tracts_sf %>%
  left_join(census_data, by = "GEOID")
```

Applied IQR-Based outlier removal for Airbnb prices: filtering outside the IQRx1.5 from Q1 and Q3 to improve visualisation. Reducing distortion from extreme luxury proporties. Additionally I am also standardising all CRS systems to 32611 which is critically measured in meters, important for this analysis.

```{r prepare-airbnb, include=FALSE}
# Calculate IQR bounds for outlier removal
Q1 <- quantile(airbnb_raw$price, 0.25, na.rm = TRUE)
Q3 <- quantile(airbnb_raw$price, 0.75, na.rm = TRUE)
IQR_val <- Q3 - Q1

# Filter outliers and convert to sf object
airbnb_sf <- airbnb_raw %>%
  filter(
    price >= (Q1 - 1.5 * IQR_val) & 
    price <= (Q3 + 1.5 * IQR_val)
  ) %>%
  st_as_sf(coords = c("longitude", "latitude")) %>%
  st_set_crs(4326) %>%      
  st_transform(32611) %>%
  st_make_valid()
```

# Spatial Distribution of Airbnb Listings

Split Airbnb listing into two categories: "Entire home/apt" versus combined "hotel room/private room/ Shared room" for a comparative analysis. Creating a dual-panel map with tmap visualisation, featuring mainland maps and Catalina Island map insets for comprehensive geographical coverage. Using a consistent dot size(0.05) and 50% transparency to allow for contrasting colours and distinguish room types. A scale bar (15km) and north arrow for spatial reference and professional cartographic standards. Revealing concentration patterns: entire homes clustered heavily in the coastal/central tourist one, while private/shared rooms showed more even distribution.

```{r figure-1, fig.cap="**Figure 1:** Spatial distribution of Airbnb listings in Los Angeles County by room type. Left panel shows entire home/apartment listings concentrated in coastal and central areas. Right panel displays hotel rooms, private rooms, and shared rooms with similar geographic patterns but lower densities.", fig.width=14, fig.height=8}


airbnb_entire <- airbnb_sf %>%
  filter(room_type == "Entire home/apt")

airbnb_other <- airbnb_sf %>%
  filter(room_type %in% c("Hotel room", "Private room", "Shared room"))

tmap_mode("plot")

# Panel 1: Entire Home/Apartment
main_entire <- tm_shape(census_tracts_sf, bbox = mainland_bbox) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_shape(airbnb_entire) +
  tm_dots(fill = "darkblue", size = 0.05, fill_alpha = 0.5) +
  tm_title("Entire Home/Apartment", fontface = "bold", size = 1.2) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_layout(frame = TRUE)

inset_entire <- tm_shape(census_tracts_sf, bbox = catalina_bbox) +
  tm_fill(fill = "grey95") +
  tm_borders(col = "grey70", lwd = 0.5) +
  tm_shape(airbnb_entire) +
  tm_dots(fill = "darkblue", size = 0.2, fill_alpha = 0.7) +
  tm_title("Catalina Island", size = 0.7, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white")

# Panel 2: Hotel/Private/Shared Room
main_other <- tm_shape(census_tracts_sf, bbox = mainland_bbox) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_shape(airbnb_other) +
  tm_dots(fill = "darkred", size = 0.05, fill_alpha = 0.5) +
  tm_title("Hotel / Private / Shared Room", fontface = "bold", size = 1.2) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_layout(frame = TRUE)

inset_other <- tm_shape(census_tracts_sf, bbox = catalina_bbox) +
  tm_fill(fill = "grey95") +
  tm_borders(col = "grey70", lwd = 0.5) +
  tm_shape(airbnb_other) +
  tm_dots(fill = "darkred", size = 0.2, fill_alpha = 0.7) +
  tm_title("Catalina Island", size = 0.7, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white")

# Print combined figure
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col = 1))
print(main_entire, vp = viewport(x = 0.5, y = 0.5, width = 0.95, height = 0.95))
print(inset_entire, vp = viewport(x = 0.78, y = 0.17, width = 0.22, height = 0.28))
popViewport()
pushViewport(viewport(layout.pos.col = 2))
print(main_other, vp = viewport(x = 0.5, y = 0.5, width = 0.95, height = 0.95))
print(inset_other, vp = viewport(x = 0.78, y = 0.17, width = 0.22, height = 0.28))
popViewport()
```

# Mean Airbnb Prices by Census Tract

Performed a spatial join between Airbnb point data and census tract polygons to aggregate listings by administrative boundaries while dealing with NA values. Additionally, identified top 3 highest and the bottom three lowest price areas for annotation. Using markers to highlight extreme values. The use of Yellow - orange - red colour scheme with continuous classification to highlight price change. THe legend is placed externally to avoid obscuring map data while maintaining readability.

```{r figure-2, fig.cap="**Figure 2:** Choropleth map showing mean Airbnb prices aggregated by census tract. Golden triangles indicate the three highest-priced tracts (concentrated in coastal areas), while red circles mark the three lowest-priced tracts. Colour intensity reflects price gradient from yellow (lower) to red (higher).", fig.width=12, fig.height=10}

tract_prices <- airbnb_sf %>%
  st_join(census_tracts_sf) %>%
  st_drop_geometry() %>%
  group_by(GEOID) %>%
  summarise(mean_price = mean(price, na.rm = TRUE), .groups = 'drop')

tracts_with_prices <- census_tracts_sf %>%
  left_join(tract_prices, by = "GEOID")

all_highlight <- tracts_with_prices %>%
  filter(!is.na(mean_price)) %>%
  mutate(price_rank = rank(-mean_price, ties.method = "first")) %>%
  filter(price_rank <= 3 | price_rank >= (max(price_rank) - 2)) %>%
  mutate(
    type = ifelse(price_rank <= 3, "Highest", "Lowest"),
    label = case_when(
      price_rank == 1 ~ "1st Highest",
      price_rank == 2 ~ "2nd Highest",
      price_rank == 3 ~ "3rd Highest",
      price_rank == max(price_rank) ~ "1st Lowest",
      price_rank == max(price_rank) - 1 ~ "2nd Lowest",
      price_rank == max(price_rank) - 2 ~ "3rd Lowest"
    )
  ) %>%
  st_centroid()

highest_tracts <- all_highlight %>% 
  filter(type == "Highest") %>%
  mutate(label = factor(label, levels = c("1st Highest", "2nd Highest", "3rd Highest")))

lowest_tracts <- all_highlight %>% 
  filter(type == "Lowest") %>%
  mutate(label = factor(label, levels = c("1st Lowest", "2nd Lowest", "3rd Lowest")))

tmap_mode("plot")

# Main Map
main_choropleth <- tm_shape(tracts_with_prices, bbox = mainland_bbox) +
  tm_fill(
    fill = "mean_price",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(title = "Mean Price ($)")
  ) +
  tm_borders(col = "grey70", lwd = 0.2) +
  tm_shape(highest_tracts) +
  tm_symbols(
    shape = "label",
    shape.scale = tm_scale_categorical(values = c(24, 25, 23)),
    shape.legend = tm_legend(title = "Highest Price"),
    fill = "#DAA520", size = 0.8, col = "black", lwd = 1.2
  ) +
  tm_shape(lowest_tracts) +
  tm_symbols(
    shape = "label",
    shape.scale = tm_scale_categorical(values = c(21, 22, 8)),
    shape.legend = tm_legend(title = "Lowest Price"),
    fill = "#ee1616", size = 0.8, col = "black", lwd = 1.2
  ) +
  tm_title("Mean Airbnb Price by Census Tract", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_layout(frame = TRUE, legend.outside = TRUE, legend.outside.position = "right")

# Inset Map
inset_choropleth <- tm_shape(tracts_with_prices, bbox = catalina_bbox) +
  tm_fill(
    fill = "mean_price",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = NULL
  ) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_title("Catalina Island", size = 1.0, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white", legend.show = FALSE)

# Print combined figure
grid.newpage()
print(main_choropleth, vp = viewport(x = 0.5, y = 0.5, width = 1, height = 1))
print(inset_choropleth, vp = viewport(x = 0.87, y = 0.145, width = 0.25, height = 0.25))
```

# Socio-Economic Characteristics

Get renter occupancy data via tidycensus package using ACS variable B25003 for 2023. Then calculated percentage of renter occupied units (renter_occupied/total_units)x100 for each census tract. Join median household income data from provided ACS data to census tract geomtries. Create a two panel comparative choropleth using contrasting colour schemes: YlOrRd for rental percentages(intensity based) and GnBU for income. Positioned legends horizontally beneath maps to maximize space while ensuring colour-blind accessability. with a Continous colour scale.

```{r figure-3-data}
# Get renter data from tidycensus
renter_data <- get_acs(
  state = "CA",
  county = "Los Angeles",
  geography = "tract",
  variables = c(total_units = "B25003_001", renter_occupied = "B25003_003"),
  geometry = FALSE,
  year = 2023,
  output = "wide"
) %>% 
  mutate(pct_renter = (renter_occupiedE / total_unitsE) * 100) %>%
  select(GEOID, pct_renter)

# Join renter data to census tracts
renter_sf <- census_tracts_sf %>%
  left_join(renter_data, by = "GEOID")

# Get median income from provided census data
Median_income_sf <- census_tracts_sf %>%
  left_join(
    census_data %>% select(GEOID, Median_income = B19013_001E),
    by = "GEOID"
  )
```

```{r figure-3, fig.cap="**Figure 3:** Socio-economic characteristics of Los Angeles County census tracts. Panel A (left) shows percentage of renter-occupied housing units, with darker red indicating higher rental rates. Panel B (right) displays median household income, where darker blue represents higher income levels. Both maps reveal distinct spatial patterns of socio-economic stratification.", fig.width=14, fig.height=9}

tmap_mode("plot")

# Panel A: Renters
main_renter <- tm_shape(renter_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = "pct_renter",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(title = "Percentage Renters (%)", orientation = "landscape"), 
    col = "white", lwd = 0.1
  ) +
  tm_title("A: Renter Occupancy", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("right", "bottom"), width = 10) +
  tm_layout(frame = TRUE, 
            legend.outside = TRUE, 
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            inner.margins = c(0.02, 0.02, 0.02, 0.02))

inset_renter <- tm_shape(renter_sf, bbox = catalina_bbox) +
  tm_polygons(
    fill = "pct_renter",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(show = FALSE),
    col = "white", lwd = 0.3
  ) +
  tm_title("Catalina Is.", size = 0.6, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 1, bg.color = "white")

# Panel B: Income
main_income <- tm_shape(Median_income_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = "Median_income",
    fill.scale = tm_scale_continuous(values = "GnBu"),
    fill.legend = tm_legend(title = "Median Income ($)", orientation = "landscape"),
    col = "white", lwd = 0.1
  ) +
  tm_title("B: Median Household Income", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("right", "bottom"), width = 10) +
  tm_layout(frame = TRUE, 
            legend.outside = TRUE, 
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            inner.margins = c(0.02, 0.02, 0.02, 0.02))

inset_income <- tm_shape(Median_income_sf, bbox = catalina_bbox) +
  tm_polygons(
    fill = "Median_income",
    fill.scale = tm_scale_continuous(values = "GnBu"),
    fill.legend = tm_legend(show = FALSE),
    col = "white", lwd = 0.3
  ) +
  tm_title("Catalina Is.", size = 0.6, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 1, bg.color = "white")

# Print combined figure
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col = 1))
print(main_renter, vp = viewport(x = 0.5, y = 0.5, width = 0.98, height = 0.98))
print(inset_renter, vp = viewport(x = 0.78, y = 0.25, width = 0.22, height = 0.28))
popViewport()
pushViewport(viewport(layout.pos.col = 2))
print(main_income, vp = viewport(x = 0.5, y = 0.5, width = 0.98, height = 0.98))
print(inset_income, vp = viewport(x = 0.78, y = 0.25, width = 0.22, height = 0.28))
popViewport()
```

# Bivariate Analysis: Price and Rental Patterns
We start by spatially joining renter occupancy and Airbnb price data at census level. Using an applied natural logarithum transformation to prices(log(price)) to normalise right skewed distribution and model non-linear relationships linearly. The use of the purple - gold bivariate colour schem where axes represent Ln(price) and percentage renter simultaniously. Purple indicate high rental/low prices(vulnerable residential area); gold shows low renter/high prices(tourist zones); dark gold reveals displacement hotspots(high renter AND high prices). Focused analysis on mainland LA using defined bounding box to emphasize critical urban core.
```{r figure-4, fig.cap="**Figure 4:** Bivariate choropleth map examining the relationship between the natual logorithum of Airbnb prices and percentage of renter-occupied housing. The purple-gold color scheme simultaneously displays both variables, revealing areas where high rental rates coincide with elevated Airbnb prices.", fig.width=10, fig.height=10}

# Join renter and price data
summary_sf <- st_join(renter_sf, airbnb_sf, join = st_intersects)

# Prepare bivariate data
adjusted_summary_sf <- summary_sf %>%
  mutate(
    Price = log(price),
    `% That Rent` = pct_renter
  ) %>%
  select(GEOID, Price, `% That Rent`, geom) %>%
  st_as_sf()

tmap_mode("plot")

figure_4_bivariate <- tm_shape(adjusted_summary_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = tm_vars(c("Price", "% That Rent"), multivariate = TRUE, animate = FALSE),
    fill.scale = tm_scale_bivariate(values = "purplegold"),
    fill.chart = tm_chart_heatmap()
  ) +
  tm_title("Bivariate Map: Ln House Price and Percentage Renters", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_layout(
    frame = TRUE, 
    legend.outside = TRUE, 
    legend.outside.position = "bottom",
    legend.outside.size = 0.2,
    inner.margins = c(0.02, 0.02, 0.02, 0.02)
  )

figure_4_bivariate
```

# Restaurant Density Analysis
Loading open Street map data, creating a new bbox for LA country. 
```{r figure-5-data, cache=TRUE}
# Query OpenStreetMap for restaurants
test_bbox <- c(-119.473572, 33.493307, -117.051086, 34.633208)

q <- opq(bbox = test_bbox) %>%
  add_osm_feature(key = "amenity", value = "restaurant") %>%
  osmdata_sf()

restaurants <- q$osm_points %>% 
  select(name, geometry) %>% 
  filter(!is.na(geometry)) %>%
  st_coordinates()
```

In this section I used open street maps to filter for amenitiy="resturant" feature to extract point geometries and transform to UTM32611. I then used kernal density estimation using the function stat_density_2d_filled with 15 contour bits with a viridis colour scheme with an overlay of neighbourhood boundaries without overwhelming density surface. 


```{r figure-5, fig.cap="**Figure 5:** Kernel density estimation of restaurant locations across Los Angeles County. Warmer colors (yellow to white) indicate areas of higher restaurant concentration, highlighting commercial and tourist districts. The visualization uses a two-dimensional density estimation with contour lines to delineate density gradients.", fig.width=10, fig.height=8}

# Convert restaurants dataframe to match coordinate system
restaurants_df <- data.frame(restaurants) %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326) %>%
  st_transform(32611)

restaurants_coords <- st_coordinates(restaurants_df)

p <- ggplot() +
  stat_density_2d_filled(
    data = as.data.frame(restaurants_coords),
    aes(x = X, y = Y),
    contour_var = "density",
    bins = 15,
    alpha = 0.9,
    adjust = 1 
  ) +
  geom_sf(
    data = neighbourhoods_sf,
    fill = NA,
    colour = "white",
    linewidth = 0.2
  ) +
  scale_fill_viridis_d(
    option = "inferno",
    name = "Density",
    guide = guide_legend(reverse = TRUE)
  ) +
  coord_sf() +
  labs(
    title = "Restaurant Density",
    x = NULL,
    y = NULL
  ) +
  theme_void(base_size = 12) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", hjust = 0.5, margin = margin(b = 10), color = "white"),
    plot.background = element_rect(fill = "black", colour = NA),
    legend.text = element_text(colour = "white"),
    legend.title = element_text(colour = "white")
  )

print(p)
```

# Proximity Analysis: Airbnbs Near Restaurants
Selecting Hollywood neighbourhood from neighbourhood.geojson for analysis based on highest tourist activity and amentiy density, the filered for resturants and airbnb listings to hollywood boundary using st_filter spatial predicate. Created 200 metre buffer around each resturant point representing comfortable walking distance. Identified overlapping buffers by using st_union to create continuous accessiblity zone, then performed a spatial intersection with st_intersect to identify listings within resturant buffers. 
```{r figure-6, fig.cap="**Figure 6:** Proximity analysis showing Airbnb listings within 200-meter walking distance of restaurants in Hollywood. Dark blue points represent Airbnbs within the buffer zone (red shaded area), while grey points show listings outside this range. Red triangles mark restaurant locations. The analysis demonstrates the spatial relationship between accommodation and dining amenities.", fig.width=10, fig.height=8}

# Define target neighbourhood
chosen_neighbourhood <- "Hollywood"

# Filter to neighbourhood
target_sf <- neighbourhoods_sf %>%
  filter(neighbourhood == chosen_neighbourhood)

# Convert restaurants to sf
restaurants_sf <- q$osm_points %>%
  select(name, geometry) %>%
  filter(!is.na(geometry)) %>%
  st_as_sf() %>%
  st_transform(32611)

# Get restaurants in neighbourhood
target_restaurants <- restaurants_sf %>%
  st_filter(target_sf)

# Create 200m buffers
restaurant_buffers <- st_buffer(target_restaurants, dist = 200)
buffer_union <- st_union(restaurant_buffers)

# Get Airbnbs in neighbourhood
target_airbnbs <- airbnb_sf %>%
  st_filter(target_sf)

# Find Airbnbs within 200m
airbnbs_near <- target_airbnbs %>%
  filter(lengths(st_intersects(., restaurant_buffers)) > 0)

p <- ggplot() +
  geom_sf(data = target_sf, fill = "#f8f9fa", color = "#495057", linewidth = 0.5) +
  geom_sf(data = buffer_union, aes(fill = "Within 200m"), alpha = 0.2, color = NA) +
  geom_sf(data = target_airbnbs, aes(color = "Outside 200m"), shape = 16, size = 1, alpha = 0.4) +
  geom_sf(data = airbnbs_near, aes(color = "Airbnb (within 200m)"), shape = 16, size = 2) +
  geom_sf(data = target_restaurants, aes(color = "Restaurant"), shape = 17, size = 2) +
  annotation_scale(
    location = "br",
    width_hint = 0.15,
    style = "ticks",
    line_width = 0.5,
    height = unit(0.15, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  annotation_north_arrow(
    location = "tr",
    which_north = "true",
    height = unit(1, "cm"),
    width = unit(1, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm"),
    style = north_arrow_fancy_orienteering
  ) +
  scale_fill_manual(
    name = NULL,
    values = c("Within 200m" = "#e63946"),
    guide = guide_legend(order = 1, override.aes = list(alpha = 0.2))
  ) +
  scale_color_manual(
    name = NULL,
    values = c("Outside 200m" = "grey70", 
               "Airbnb (within 200m)" = "#1d3557", 
               "Restaurant" = "#e63946"),
    guide = guide_legend(order = 2, override.aes = list(
      shape = c(16, 16, 17),
      size = c(2, 3, 3),
      alpha = 1
    ))
  ) +
  labs(
    title = paste("Airbnb Listings within 200m of Restaurants in", chosen_neighbourhood),
    subtitle = paste0(nrow(airbnbs_near), " of ", nrow(target_airbnbs), 
                      " listings within walking distance of ", nrow(target_restaurants), " restaurants"),
    caption = "Data: Inside Airbnb & OpenStreetMap | CRS: EPSG 32611"
  ) +
  theme_void(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 13),
    plot.subtitle = element_text(hjust = 0.5, color = "grey40", margin = margin(t = 5, b = 10)),
    plot.caption = element_text(hjust = 0.5, color = "grey50", size = 8),
    plot.margin = margin(15, 15, 15, 15),
    legend.position = "bottom",
    legend.box.margin = margin(t = 10)
  )

print(p)
```

# Point Pattern Analysis
I started by converting census tract geometries to owin spatial objects windows for spatstat compatibility. Then extracted coordinates from airbnb sf object and create point pattern(ppp) with defined window boundary. Rescaled coordinates from metres to kilometers for appropriate bandwidth specification.
```{r figure-7-8-combined, fig.cap="**Figure 7:** Spatial analysis of Airbnb listings in Los Angeles. (a) Kernel density estimation using point pattern analysis with a Gaussian kernel (2km bandwidth) showing clustering patterns with contour lines indicating concentration levels. (b) Inverse distance weighted (IDW) interpolation of listing prices creating a continuous surface where warmer colors indicate higher predicted prices, revealing spatial price trends and hotspots.", fig.width=14, fig.height=7}

# Set up two-panel plot
par(mfrow = c(1, 2))

# Panel (a): Kernel Density Estimation
# Create boundary
BA_boundary <- st_union(neighbourhoods_sf)
BA_owin_m <- as.owin(BA_boundary)

# Prepare point pattern
coords <- st_coordinates(airbnb_sf)
listings_ppp <- ppp(
  x = coords[, 1],
  y = coords[, 2],
  window = BA_owin_m
)

# Rescale to km
listings_ppp <- rescale(listings_ppp, 1000)
BA_owin <- rescale(BA_owin_m, 1000)
marks(listings_ppp) <- NULL

# Calculate density
K1 <- density.ppp(listings_ppp, sigma = 2)

# Plot
plot(K1, main = "(a) Kernel Density of Airbnb Listings", las = 1)
contour(K1, add = TRUE)
plot(BA_owin, add = TRUE)

# Panel (b): IDW Interpolation
# Prepare listings with price marks
listings_transformed <- airbnb_sf %>%
  filter(!is.na(price), price > 0)

coords_price <- st_coordinates(listings_transformed)

# Create ppp with price marks
listings_ppp_price <- ppp(
  x = coords_price[, 1],
  y = coords_price[, 2],
  marks = listings_transformed$price,
  window = BA_owin_m
)

# Rescale to km
listings_ppp_price <- rescale(listings_ppp_price, 1000)

# IDW interpolation
price_idw <- Smooth.ppp(listings_ppp_price, sigma = 2)

# Plot
plot(price_idw, main = "(b) IDW Interpolation of Prices", las = 1)
contour(price_idw, add = TRUE)
plot(BA_owin, add = TRUE)

# Reset plotting parameters
par(mfrow = c(1, 1))
```

# Figure 8: Transit Oriented Displacement
I downloaded the LA Metro Red/Purple Line data from the Metro website, which included both the train tracks and station locations, then changed everything to use the same coordinate system (UTM Zone 11N) as the rest of my project. I created 400-metre circles around each station to show the area people can easily walk to from the station. I then counted how many Airbnb listings were inside each of these circles by joining the station buffers with the Airbnb data. I added these counts back to the station data so I could show them on the map using different sized circles, where bigger circles mean more Airbnb listings near that station. I found the vulnerable neighborhoods by looking for census tracts where more than 50% of people rent rather than own their homes, since these areas are more likely to lose housing when landlords switch to short-term rentals. I created a 1km-wide zone along the entire train line to show the area influenced by the transit system. I then filtered to only show the vulnerable tracts that fall within this transit zone, which shows where high numbers of renters live close to the metro stations. I selected several key neighborhoods like Hollywood, Koreatown, Downtown, West Hollywood, and others to show their boundaries on the map for context. I built the map in layers, starting with the vulnerable tracts shown in yellow-orange-red colors based on the percentage of renters, then adding neighborhood outlines in grey, station circles as dashed red lines, and the train route as a solid red line. I added the Airbnb listings as small gold dots, but only showed the ones near stations to keep the map clear. I showed each station as a dark red circle where the size shows how many Airbnbs are nearby, ranging from very small (0 listings) to large (500+ listings). I added a scale bar at the bottom and a north arrow at the top to help people read the map properly. I created a small overview map in the corner showing where the Red/Purple Line sits within all of LA County, using grey for the background and red to highlight the train line and vulnerable areas. The map shows that the biggest clusters of Airbnbs are at Hollywood (over 100 listings), Koreatown (90-100 listings), and downtown (80-100 listings), all in areas where most people rent their homes, while stations at the ends of the line have far fewer Airbnbs, suggesting that being in the city center matters more than just having a train station nearby.
```{r}
# Download Red/Purple Line data
url_metro <- "https://developer.metro.net/wp-content/uploads/2019/10/802_Red_Purple_Track_0316.zip"
url_station <- "https://developer.metro.net/wp-content/uploads/2019/10/802_805_RedPurple_Stations_0316.zip"

if(!file.exists(file.path(ddir,"red-purple-line"))){
  download.file(url = url_metro, destfile = file.path(ddir, "red-purple-line.zip"))
  unzip(file.path(ddir, "red-purple-line.zip"), exdir = file.path(ddir, 'red-purple-line'))
}

if(!file.exists(file.path(ddir,"red-purple-stations"))){
  download.file(url = url_station, destfile = file.path(ddir, "red-purple-stations.zip"))
  unzip(file.path(ddir, "red-purple-stations.zip"), exdir = file.path(ddir, 'red-purple-stations'))
}

# Read and transform data
red_purple_line_sf <- st_read(file.path(ddir, "red-purple-line/802_805_Track_0316.shp")) %>% 
  st_transform(32611)

station <- st_read(file.path(ddir, "red-purple-stations/RedPurpleLine0316.shp")) %>% 
  select(STATION, geometry) %>% 
  st_transform(32611)

# Create 400m buffers around stations
station_buffers <- st_buffer(station, dist = 400)

# Spatial join to count Airbnb listings within buffers
airbnb_near_redpurple <- st_join(airbnb_sf, station_buffers, left = FALSE) %>%
  st_drop_geometry()

# Count listings per station
station_counts <- airbnb_near_redpurple %>%
  group_by(STATION) %>%
  summarise(n_airbnb = n()) %>%
  ungroup()

# Join counts back to station data
station_with_counts <- station %>%
  left_join(station_counts, by = "STATION") %>%
  mutate(n_airbnb = replace_na(n_airbnb, 0))

# Identify vulnerable census tracts (>50% renters) along the Red/Purple Line
redpurple_corridor <- st_buffer(red_purple_line_sf, dist = 1000) %>% st_union()

vulnerable_tracts_redpurple <- renter_sf %>%
  filter(pct_renter > 50) %>%
  st_filter(redpurple_corridor, .predicate = st_intersects)

# Filter to key neighborhoods for context
key_neighborhoods <- neighbourhoods_sf %>%
  filter(neighbourhood %in% c("Hollywood", "Koreatown", "Downtown", 
                               "West Hollywood", "Silver Lake", "Echo Park",
                               "Venice", "Santa Monica", "Beverly Hills",
                               "Westwood", "Mid-City"))

# Create main Figure 8
fig8_main <- ggplot() +
  # Vulnerable census tracts in background
  geom_sf(data = vulnerable_tracts_redpurple, 
          aes(fill = pct_renter), 
          color = "grey80", alpha = 0.5) +
  scale_fill_distiller(palette = "YlOrRd", direction = 1,
                       name = "% Renter\nOccupied",
                       limits = c(50, 100)) +
  
  # Add neighborhood boundaries for context (NO LABELS)
  geom_sf(data = key_neighborhoods,
          fill = NA, color = "grey30", linewidth = 0.8, linetype = "solid") +
  
  # Station buffers
  geom_sf(data = station_buffers, 
          fill = NA, color = "#E31837", 
          linetype = "dashed", linewidth = 0.5, alpha = 0.6) +
  
  # Red/Purple Line route
  geom_sf(data = red_purple_line_sf, 
          color = "#E31837", linewidth = 1.5) +
  
  # Airbnb points within buffers
  geom_sf(data = airbnb_sf %>% st_filter(station_buffers),
          color = "gold", size = 0.5, alpha = 0.4) +
  
  # Stations sized by Airbnb count
  geom_sf(data = station_with_counts,
          aes(size = n_airbnb), 
          color = "darkred", alpha = 0.8, shape = 16) +
  scale_size_continuous(name = "Airbnb\nListings\nwithin 400m",
                        range = c(2, 8),
                        breaks = c(0, 100, 200, 300, 400, 500)) +
  
  # Add scale bar and north arrow
  annotation_scale(
    location = "br",
    width_hint = 0.15,
    style = "ticks",
    line_width = 0.5,
    height = unit(0.15, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  annotation_north_arrow(
    location = "tr",
    which_north = "true",
    height = unit(1, "cm"),
    width = unit(1, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm"),
    style = north_arrow_fancy_orienteering
  ) +
  
  # Styling
  theme_void() +
  theme(
    legend.position = "right",
    legend.background = element_rect(fill = "white", color = "grey50"),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 13),
    plot.subtitle = element_text(hjust = 0.5, color = "grey40", margin = margin(t = 5, b = 10)),
    plot.caption = element_text(hjust = 0.5, color = "grey50", size = 8),
    plot.margin = margin(15, 15, 15, 15)
  ) +
  labs(
    title = "Airbnb Clustering Along the Red/Purple Line",
    subtitle = "Transit-oriented displacement in Hollywood, Koreatown, and Downtown",
    caption = "Data: Inside Airbnb, LA Metro, ACS 2019-2023 | CRS: EPSG 32611"
  )

# Create inset overview map
inset_overview <- ggplot() +
  geom_sf(data = census_tracts_sf, fill = "grey90", color = "grey80", linewidth = 0.1) +
  geom_sf(data = red_purple_line_sf, color = "#E31837", linewidth = 2) +
  geom_sf(data = vulnerable_tracts_redpurple, fill = "#E31837", alpha = 0.3, color = NA) +
  theme_void() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
    plot.background = element_rect(fill = "white", color = NA)
  )

# Print with inset (similar to your Figure 1 and 2 approach)
grid.newpage()
print(fig8_main, vp = viewport(x = 0.5, y = 0.5, width = 1, height = 1))
print(inset_overview, vp = viewport(x = 0.15, y = 0.22, width = 0.25, height = 0.25))
```