---
title: "Assessment 2 GY476"
output:
  html_document: default
  pdf_document: default
---

# =============================================================================
# SETUP: Load packages and set directories
# =============================================================================
```{r setup}
# Set working directory
wdir <- "/Users/dylanhillier/Library/CloudStorage/OneDrive-LondonSchoolofEconomics/GY476_Geographic_Information_System/assessment02"

# Load required packages
if(!require("tidyverse")) install.packages("tidyverse")
library(tidyverse)
library(ggplot2)
library(dplyr)
library(sf)
library(tmap)
library(tidycensus)
library(grid)

# Create data directory if it doesn't exist
if(!dir.exists(file.path(wdir, "data"))) {
  dir.create(file.path(wdir, "data"))
}
ddir <- file.path(wdir, "data")

# Census API key
census_api_key("c990ed72472399dd626592b06afee9a188d03320", install = TRUE, overwrite = TRUE)
```

# =============================================================================
# DOWNLOAD DATA: Airbnb listings and neighbourhood boundaries
# =============================================================================
```{r download-data}
# Download Airbnb listings
download.file(
  url = "https://data.insideairbnb.com/united-states/ca/los-angeles/2025-09-01/visualisations/listings.csv",
  destfile = file.path(ddir, "listing.csv")
)

# Download neighbourhood boundaries
download.file(
  url = "https://data.insideairbnb.com/united-states/ca/los-angeles/2025-09-01/visualisations/neighbourhoods.geojson",
  destfile = file.path(ddir, "neighbourhoods.geojson")
)
```

# =============================================================================
# LOAD DATA: Read in all datasets
# =============================================================================
```{r load-data}
# Airbnb listings
airbnb_raw <- read.csv(file.path(ddir, "listing.csv"))

# Neighbourhood boundaries
neighbourhoods_sf <- st_read(file.path(ddir, "neighbourhoods.geojson"))

# LA census tract geometry
census_tracts_sf <- st_read(file.path(ddir, "LA_geometry.gpkg")) %>%
  st_transform(32611)

# Census data
census_data <- read.csv(file.path(ddir, "ACS_2019_2023_LA_vars.csv")) %>%
  tibble() %>%
  mutate(
    GEOID = as.character(GEOID),
    GEOID = paste0("06", str_sub(GEOID, start = 2))
  )

# Define bounding boxes (reused for all maps)
mainland_bbox <- st_bbox(c(xmin = 320000, ymin = 3710000, 
                           xmax = 445000, ymax = 3860000), 
                         crs = 32611)

catalina_bbox <- st_bbox(c(xmin = 340000, ymin = 3678000, 
                           xmax = 390000, ymax = 3708000), 
                         crs = 32611)
```

# =============================================================================
# JOIN DATA: Combine census geometry with census data
# =============================================================================
```{r join-census}
census_joined <- census_tracts_sf %>%
  left_join(census_data, by = "GEOID")
```

# =============================================================================
# PREPARE AIRBNB DATA: Remove outliers and convert to spatial
# =============================================================================
```{r prepare-airbnb}
# Calculate IQR bounds for outlier removal
Q1 <- quantile(airbnb_raw$price, 0.25, na.rm = TRUE)
Q3 <- quantile(airbnb_raw$price, 0.75, na.rm = TRUE)
IQR_val <- Q3 - Q1

# Filter outliers and convert to sf object
airbnb_sf <- airbnb_raw %>%
  tibble() %>%
  filter(
    price >= (Q1 - 1.5 * IQR_val) & 
    price <= (Q3 + 1.5 * IQR_val)
  ) %>%
  st_as_sf(coords = c("longitude", "latitude")) %>%
  st_set_crs(4326) %>%      
  st_transform(32611) %>%
  st_make_valid()
```

# =============================================================================
# FIGURE 1: Airbnb Listings by Room Type (Two-panel map)
# =============================================================================
```{r figure-1}
# Split by room type
airbnb_entire <- airbnb_sf %>%
  filter(room_type == "Entire home/apt")

airbnb_other <- airbnb_sf %>%
  filter(room_type %in% c("Hotel room", "Private room", "Shared room"))

tmap_mode("plot")

# ---- Panel 1: Entire Home/Apartment ----
main_entire <- tm_shape(census_tracts_sf, bbox = mainland_bbox) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_shape(airbnb_entire) +
  tm_dots(fill = "darkblue", size = 0.05, fill_alpha = 0.5) +
  tm_title("Entire Home/Apartment", fontface = "bold", size = 1.2) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_layout(frame = TRUE)

inset_entire <- tm_shape(census_tracts_sf, bbox = catalina_bbox) +
  tm_fill(fill = "grey95") +
  tm_borders(col = "grey70", lwd = 0.5) +
  tm_shape(airbnb_entire) +
  tm_dots(fill = "darkblue", size = 0.2, fill_alpha = 0.7) +
  tm_title("Catalina Island", size = 0.7, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white")

# ---- Panel 2: Hotel/Private/Shared Room ----
main_other <- tm_shape(census_tracts_sf, bbox = mainland_bbox) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_shape(airbnb_other) +
  tm_dots(fill = "darkred", size = 0.05, fill_alpha = 0.5) +
  tm_title("Hotel / Private / Shared Room", fontface = "bold", size = 1.2) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_layout(frame = TRUE)

inset_other <- tm_shape(census_tracts_sf, bbox = catalina_bbox) +
  tm_fill(fill = "grey95") +
  tm_borders(col = "grey70", lwd = 0.5) +
  tm_shape(airbnb_other) +
  tm_dots(fill = "darkred", size = 0.2, fill_alpha = 0.7) +
  tm_title("Catalina Island", size = 0.7, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white")

# ---- Save Figure 1 ----
png(file.path(ddir, "figure_1_room_types.png"), width = 14, height = 8, units = "in", res = 300)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col = 1))
print(main_entire, vp = viewport(x = 0.5, y = 0.5, width = 0.95, height = 0.95))
print(inset_entire, vp = viewport(x = 0.78, y = 0.17, width = 0.22, height = 0.28))
popViewport()
pushViewport(viewport(layout.pos.col = 2))
print(main_other, vp = viewport(x = 0.5, y = 0.5, width = 0.95, height = 0.95))
print(inset_other, vp = viewport(x = 0.78, y = 0.17, width = 0.22, height = 0.28))
popViewport()
dev.off()
```

# =============================================================================
# FIGURE 2: Mean Airbnb Price by Census Tract (Choropleth)
# =============================================================================
```{r figure-2}
# Fix invalid geometries
census_tracts_sf <- st_make_valid(census_tracts_sf)
airbnb_sf <- st_make_valid(airbnb_sf)

# Calculate mean price per census tract
tract_prices <- airbnb_sf %>%
  st_join(census_tracts_sf) %>%
  st_drop_geometry() %>%
  group_by(GEOID) %>%
  summarise(mean_price = mean(price, na.rm = TRUE))

# Join prices back to census tract geometry
tracts_with_prices <- census_tracts_sf %>%
  left_join(tract_prices, by = "GEOID")

# Identify top 3 and bottom 3 tracts by price
all_highlight <- tracts_with_prices %>%
  filter(!is.na(mean_price)) %>%
  mutate(price_rank = rank(-mean_price, ties.method = "first")) %>%
  filter(price_rank <= 3 | price_rank >= (max(price_rank) - 2)) %>%
  mutate(
    type = ifelse(price_rank <= 3, "Highest", "Lowest"),
    label = case_when(
      price_rank == 1 ~ "1st Highest",
      price_rank == 2 ~ "2nd Highest",
      price_rank == 3 ~ "3rd Highest",
      price_rank == max(price_rank) ~ "1st Lowest",
      price_rank == max(price_rank) - 1 ~ "2nd Lowest",
      price_rank == max(price_rank) - 2 ~ "3rd Lowest"
    )
  ) %>%
  st_centroid()

# Split into highest and lowest
highest_tracts <- all_highlight %>% 
  filter(type == "Highest") %>%
  mutate(label = factor(label, levels = c("1st Highest", "2nd Highest", "3rd Highest")))

lowest_tracts <- all_highlight %>% 
  filter(type == "Lowest") %>%
  mutate(label = factor(label, levels = c("1st Lowest", "2nd Lowest", "3rd Lowest")))

# ---- Main Map (Mainland) ----
tmap_mode("plot")

main_choropleth <- tm_shape(tracts_with_prices, bbox = mainland_bbox) +
  tm_fill(
    fill = "mean_price",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(title = "Mean Price ($)")
  ) +
  tm_borders(col = "grey70", lwd = 0.2) +
  tm_shape(highest_tracts) +
  tm_symbols(
    shape = "label",
    shape.scale = tm_scale_categorical(values = c(24, 25, 23)),
    shape.legend = tm_legend(title = "Highest Price"),
    fill = "#DAA520", size = 0.8, col = "black", lwd = 1.2
  ) +
  tm_shape(lowest_tracts) +
  tm_symbols(
    shape = "label",
    shape.scale = tm_scale_categorical(values = c(21, 22, 8)),
    shape.legend = tm_legend(title = "Lowest Price"),
    fill = "#ee1616", size = 0.8, col = "black", lwd = 1.2
  ) +
  tm_title("Mean Airbnb Price by Census Tract", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 2.4) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_layout(frame = TRUE, legend.outside = TRUE, legend.outside.position = "right")

# ---- Inset Map (Catalina Island) ----
inset_choropleth <- tm_shape(tracts_with_prices, bbox = catalina_bbox) +
  tm_fill(
    fill = "mean_price",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = NULL
  ) +
  tm_borders(col = "grey70", lwd = 0.3) +
  tm_title("Catalina Island", size = 1.0, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 2, bg.color = "white", legend.show = FALSE)

# ---- Save Figure 2 ----
png(file.path(ddir, "figure_2_choropleth.png"), width = 12, height = 10, units = "in", res = 300)
grid.newpage()
print(main_choropleth, vp = viewport(x = 0.5, y = 0.5, width = 1, height = 1))
print(inset_choropleth, vp = viewport(x = 0.87, y = 0.145, width = 0.25, height = 0.25))
dev.off()
```

# =============================================================================
# FIGURE 3: Socio-economic Variables (Combined Panel)
# =============================================================================

# ---- 1. Data Preparation ----
# (Your existing code correctly standardizes renters by total units) 
# =============================================================================
# FIGURE 3: Socio-economic Variables (Combined Panel)
# =============================================================================
```{r figure-3-data}
# Get renter data from tidycensus (Uses get_acs)
renter_data <- get_acs(
  state = "CA",
  county = "Los Angeles",
  geography = "tract",
  variables = c(total_units = "B25003_001", renter_occupied = "B25003_003"),
  geometry = TRUE,
  year = 2023,
  output = "wide"
) %>% 
  tibble() %>%
  # Calculate Percentage Renters
  mutate(pct_renter = (renter_occupiedE / total_unitsE) * 100) %>%
  select(GEOID, pct_renter)

# Join renter data to census tracts (used for Panel A)
renter_sf <- census_tracts_sf %>%
  left_join(renter_data, by = "GEOID") %>%
  st_make_valid() %>%
  st_transform(crs = 32611)

# Get median income from provided census data
Median_income <- census_data %>% 
  select(GEOID, Median_income = B19013_001E) %>%
  filter(!is.na(Median_income)) 

# Join median income to census tracts (used for Panel B & Figure 4)
Median_income_sf <- census_tracts_sf %>%
  left_join(Median_income, by = "GEOID") %>%
  st_make_valid() %>%
  st_transform(crs = 32611)
```

# ... [Keep your data preparation code from step 1 exactly the same] ...
```{r}
# ---- 2. Define Map Objects ----
tmap_mode("plot")

# -- Panel A: Renters --
main_renter <- tm_shape(renter_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = "pct_renter",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    # Orientation landscape works best for bottom legends
    fill.legend = tm_legend(title = "Percentage Renters (%)", orientation = "landscape"), 
    col = "white", lwd = 0.1
  ) +
  tm_title("A: Renter Occupancy", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("right", "bottom"), width = 10) +
  # CHANGE: Move legend outside to the bottom
  tm_layout(frame = TRUE, 
            legend.outside = TRUE, 
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            inner.margins = c(0.02, 0.02, 0.02, 0.02))

inset_renter <- tm_shape(renter_sf, bbox = catalina_bbox) +
  tm_polygons(
    fill = "pct_renter",
    fill.scale = tm_scale_continuous(values = "YlOrRd"),
    fill.legend = tm_legend(show = FALSE),
    col = "white", lwd = 0.3
  ) +
  tm_title("Catalina Is.", size = 0.6, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 1, bg.color = "white")

# -- Panel B: Income --
main_income <- tm_shape(Median_income_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = "Median_income",
    fill.scale = tm_scale_continuous(values = "GnBu"),
    # Orientation landscape works best for bottom legends
    fill.legend = tm_legend(title = "Median Income ($)", orientation = "landscape"),
    col = "white", lwd = 0.1
  ) +
  tm_title("B: Median Household Income", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("right", "bottom"), width = 10) +
  # CHANGE: Move legend outside to the bottom
  tm_layout(frame = TRUE, 
            legend.outside = TRUE, 
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            inner.margins = c(0.02, 0.02, 0.02, 0.02))

inset_income <- tm_shape(Median_income_sf, bbox = catalina_bbox) +
  tm_polygons(
    fill = "Median_income",
    fill.scale = tm_scale_continuous(values = "GnBu"),
    fill.legend = tm_legend(show = FALSE),
    col = "white", lwd = 0.3
  ) +
  tm_title("Catalina Is.", size = 0.6, fontface = "bold") +
  tm_layout(frame = TRUE, frame.lwd = 1, bg.color = "white")

# ---- 3. Render Combined Figure ----
png(file.path(ddir, "figure_3_socioeconomic_combined.png"), width = 14, height = 9, units = "in", res = 300)

grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))

# --- Left Column (Renters) ---
pushViewport(viewport(layout.pos.col = 1))
  print(main_renter, vp = viewport(x = 0.5, y = 0.5, width = 0.98, height = 0.98))
  # Adjusted y position slightly to account for the layout change
  print(inset_renter, vp = viewport(x = 0.78, y = 0.25, width = 0.22, height = 0.28))
popViewport()

# --- Right Column (Income) ---
pushViewport(viewport(layout.pos.col = 2))
  print(main_income, vp = viewport(x = 0.5, y = 0.5, width = 0.98, height = 0.98))
  # Adjusted y position slightly to account for the layout change
  print(inset_income, vp = viewport(x = 0.78, y = 0.25, width = 0.22, height = 0.28))
popViewport()

dev.off()
```

#figure 4 need to get bivariate map of renter data percentage and ln(of price of )

```{r}
library(ggplot2)


summary_sf <- st_join(renter_sf, airbnb_sf, join = st_intersects) %>%
  tibble()
  
tmap_mode = "plot"
# Rename for clarity and select only the necessary columns/geometry for mapping
adjusted_summary_sf <- summary_sf %>%
  mutate(
    Price = log(price),
    `% That Rent` = pct_renter
  ) %>%
  select(GEOID, Price, `% That Rent`, geom) %>%
  st_as_sf()

# Check the result (should be an sf object with 3 non-geometry columns)
# head(adjusted_summary_sf)
 
# =============================================================================
# FIGURE 4: Bivariate Map (Ln Price and Percentage Renters)
# =============================================================================

tmap_mode("plot")

figure_4_bivariate <- tm_shape(adjusted_summary_sf, bbox = mainland_bbox) +
  tm_polygons(
    fill = tm_vars(c("Price", "% That Rent"), multivariate = TRUE, animate = FALSE),
    fill.scale = tm_scale_bivariate(values = "purplegold"),
    fill.chart = tm_chart_heatmap()
  ) +
  tm_title("Bivariate Map: Ln House Price and Percentage Renters", fontface = "bold", size = 1.2) +
  tm_compass(type = "arrow", position = c("right", "top"), size = 1.5) +
  tm_scalebar(position = c("left", "bottom"), width = 15) +
  tm_layout(
    frame = TRUE, 
    legend.outside = TRUE, 
    legend.outside.position = "bottom",
    legend.outside.size = 0.2,
    inner.margins = c(0.02, 0.02, 0.02, 0.02)
  )

figure_4_bivariate

# Save Figure 4
tmap_save(figure_4_bivariate, 
          filename = file.path(ddir, "figure_4_bivariate.png"), 
          width = 10, height = 10, units = "in", dpi = 300, device = png)


```


Query OpenStreetMap data

```{r open street map}
if(!require("osmdata")) install.packages("osmdata")
library("osmdata")




test_bbox <- c(-119.473572,33.493307,-117.051086,34.633208)

q <- opq(bbox = test_bbox) |>
 add_osm_feature(key = "amenity", value = "restaurant") |>
 osmdata_sf ()
resturants <- q$osm_points %>% select(name, geometry) %>% filter(!is.na(geometry)) %>%
  st_coordinates()

p <- ggplot() +
  stat_density_2d_filled(
    data = resturants,
    aes(x = X, y = Y),
    contour_var = "density",
    bins = 15,
    alpha = 0.9,
    # 'adjust' controls the smoothness. 
    # If the blobs look too jagged after zooming out, try increasing this (e.g., 1.5)
    adjust = 1 
  ) +
  geom_sf(
    data = neighbourhoods_sf,
    fill = NA,
    colour = "white",
    linewidth = 0.2
  ) +
  scale_fill_viridis_d(
    option = "inferno",
    name = "Density",
    guide = guide_legend(reverse = TRUE)
  ) +
  coord_sf() +
  labs(
    title = "Restaurant Density",
    x = NULL,
    y = NULL
  ) +
  theme_void(base_size = 12) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", hjust = 0.5, margin = margin(b = 10), color = "white"), # Added color white for visibility
    plot.background = element_rect(fill = "black", colour = NA),
    legend.text = element_text(colour = "white"),
    legend.title = element_text(colour = "white")
  )

ggsave(file.path(ddir, "figure5.png"), p, width = 10, height = 8, dpi = 300)

```

figure 6
```{r}
library(sf)
library(dplyr)
library(ggplot2)

restaurants_sf <- q$osm_points %>%
  select(name, geometry) %>%
  filter(!is.na(geometry)) %>%
  st_as_sf()
# Set your chosen neighbourhood
chosen_neighbourhood <- "Hollywood"

# Filter to neighbourhood
target_sf <- neighbourhoods_sf %>%
  filter(neighbourhood == chosen_neighbourhood) %>%
  st_transform(crs = 32611)

# Get restaurants in that neighbourhood
target_restaurants <- restaurants_sf %>%
  st_transform(crs = 32611) %>%
  st_filter(target_sf)

# Create 200m buffers
restaurant_buffers <- st_buffer(target_restaurants, dist = 200)
buffer_union <- st_union(restaurant_buffers)

# Get all Airbnbs in neighbourhood
target_airbnbs <- airbnb_sf %>%
  st_transform(crs = 32611) %>%
  st_filter(target_sf)

# Find Airbnbs within 200m of restaurants
airbnbs_near <- target_airbnbs %>%
  filter(lengths(st_intersects(., restaurant_buffers)) > 0)

library(ggspatial)

p <- ggplot() +
  geom_sf(data = target_sf, fill = "#f8f9fa", color = "#495057", linewidth = 0.5) +
  geom_sf(data = buffer_union, aes(fill = "Within 200m"), alpha = 0.2, color = NA) +
  geom_sf(data = target_airbnbs, aes(color = "Outside 200m"), shape = 16, size = 1, alpha = 0.4) +
  geom_sf(data = airbnbs_near, aes(color = "Airbnb (within 200m)"), shape = 16, size = 2) +
  geom_sf(data = target_restaurants, aes(color = "Restaurant"), shape = 17, size = 2) +
  annotation_scale(
    location = "br",
    width_hint = 0.15,
    style = "ticks",
    line_width = 0.5,
    height = unit(0.15, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  annotation_north_arrow(
    location = "tr",
    which_north = "true",
    height = unit(1, "cm"),
    width = unit(1, "cm"),
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm"),
    style = north_arrow_fancy_orienteering
  ) +
  scale_fill_manual(
    name = NULL,
    values = c("Within 200m" = "#e63946"),
    guide = guide_legend(order = 1, override.aes = list(alpha = 0.2))
  ) +
  scale_color_manual(
    name = NULL,
    values = c("Outside 200m" = "grey70", 
               "Airbnb (within 200m)" = "#1d3557", 
               "Restaurant" = "#e63946"),
    guide = guide_legend(order = 2, override.aes = list(
      shape = c(16, 16, 17),
      size = c(2, 3, 3),
      alpha = 1
    ))
  ) +
  labs(
    title = paste("Airbnb Listings within 200m of Restaurants in", chosen_neighbourhood),
    subtitle = paste0(nrow(airbnbs_near), " of ", nrow(target_airbnbs), 
                      " listings within walking distance of ", nrow(target_restaurants), " restaurants"),
    caption = "Data: Inside Airbnb & OpenStreetMap | CRS: EPSG 32611"
  ) +
  theme_void(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 13),
    plot.subtitle = element_text(hjust = 0.5, color = "grey40", margin = margin(t = 5, b = 10)),
    plot.caption = element_text(hjust = 0.5, color = "grey50", size = 8),
    plot.margin = margin(15, 15, 15, 15),
    legend.position = "bottom",
    legend.box.margin = margin(t = 10)
  )

p

```


pattern point analysis of airbnb price

```{r}

library(spatstat)
library(sf)

# Create window (don't rescale yet)
neighbourhoods_sf_transformed <- neighbourhoods_sf %>% 
  st_set_crs(4326) %>% 
  st_transform(32611)

BA_boundary <- st_union(neighbourhoods_sf_transformed)
BA_owin_m <- as.owin(BA_boundary)

# Transform listings
listings_transformed <- airbnb_sf %>%
  st_transform(32611)

coords <- st_coordinates(listings_transformed)

# Create ppp with unscaled window (both in metres)
listings_ppp <- ppp(
  x = coords[, 1],
  y = coords[, 2],
  window = BA_owin_m
)

# Now rescale everything together
listings_ppp <- rescale(listings_ppp, 1000)
BA_owin <- rescale(BA_owin_m, 1000)

marks(listings_ppp) <- NULL

# Plot
K1 <- density.ppp(listings_ppp) 
plot(K1, main = NULL, las = 1)
contour(K1, add = TRUE)
plot(BA_owin, add = TRUE)
```